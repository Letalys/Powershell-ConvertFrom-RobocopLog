<#
.SYNOPSIS
    Analyzes and converts a Robocopy log file into a structured PowerShell object.

.DESCRIPTION
    The `ConvertFrom-RobocopLog` script parses a log file generated by Robocopy and extracts header information, 
    a list of files according to their Robocopy class, created directories, and summary statistics.
    
    It handles logs in both English and French and returns a PowerShell object containing the extracted data.
    The script is compatible with various Robocopy options, but some are required or prohibited for optimal functioning. (see the Notes section)

.PARAMETER RoboLog
    (Mandatory) The path to the Robocopy log file to analyze.

.PARAMETER LogLanguage
    (Optional) Specifies the log file language. Defaults to "en-US". Available options are "en-US" and "fr-FR".

.PARAMETER FailedList
    (Optional) Specifies whether error file lists are returned and how they should be parsed.

.EXAMPLE
    $Log = .\ConvertFrom-RobocopLog.ps1 -RoboLog "C:\Logs\RobocopyLog.log"
    $Log = .\ConvertFrom-RobocopLog.ps1 -RoboLog "C:\Logs\RobocopyLog.txt" -LogLanguage "en-US"
    $Log = .\ConvertFrom-RobocopLog.ps1 -RoboLog "C:\Logs\Log1.txt" -LogLanguage "fr-FR" -FailedList "Parsed"
    $Log = .\ConvertFrom-RobocopLog.ps1 -RoboLog "C:\Logs\Log1.txt" -LogLanguage "fr-FR" -FailedList "Raw"
    
    $Log.HeaderInfo.Start : Provides the start date and time from the header if available.
    $Log.Files.Failed : Get Failed file list
    $Log.SummaryInfo : Get a parse of the resume

.NOTES
    WARNING               : For this script to work properly, certain Robocopy log options must be considered.
								(REQUIRED OPTION)  /fp              : Ensures that full file paths are logged.
								(FORBIDDEN OPTION) /nc              : Specifies that file classes will not be recorded.

								(fr-FR OPTION)     /unicode:<Log>   : To be used instead of /log for proper handling of accents.
                                                                      Be aware that in Unicode, some characters are non-breaking.
                                                                      They must be directly added to the culture map. Check fr-FR CultureMap.
                         
    AUTHOR              : Letalys

    SCRIPT              : ConvertFrom-RobocopLogLite.ps1
    SCRIPTVERSION       : 1.0

    RELEASENOTES        :   Version 1.0  | 2024-10-14
                                Initial version.

#>


param (
    [Parameter(Mandatory = $true)]
    [ValidateScript({ Test-Path -Path $_ })]
    [String]$RoboLog,

    [Parameter(Mandatory = $false)]
    [ValidateSet("en-US", "fr-FR")]
    [String]$LogLanguage = "en-US",

    [Parameter(Mandatory = $false)]
    [ValidateSet("None", "Raw","Parsed")]
    [String]$FailedList = "None"
)

function ConvertFrom-RobocopLogLite {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [ValidateScript({ Test-Path -Path $_ })]
        [String]$RoboLog,

        [Parameter(Mandatory = $false)]
        [ValidateSet("en-US", "fr-FR")]
        [String]$LogLanguage = "en-US",

        [Parameter(Mandatory = $false)]
        [ValidateSet("None", "Raw","Parsed")]
        [String]$FailedList = "None"
    )
    # Management of keyword dictionaries according to language.
    $CultureMap = @{
        "en-US" = @{
            #RobocopParsing
            RobocopParsingStart    = "Start parsing..."
            RobocopParsingFinalize = "End parsing..."

			#Parsing header
            Start        = "Started :"
            Source       = "Source :"
            Destination  = "Dest :"
            FilesSection = "Files :"
            Options      = "Options :"
			
			#Parsing Files
            NewFile      = "New File"
            NewerFile    = "Newer"
            OlderFile    = "Older"
            SameFile     = "same"
			ExtraFile    = "EXTRA File"
            ModifiedFile = "Modified"
            LonelyFile   = "lonely"
            TweakedFile  = "tweaked"
			
			#Parsing Directories
            NewDir       = "New Dir"
            ExtraDir     = "EXTRA Dir"
            LonelyDir    = "lonely"

            #Error
            Error             = "ERROR"
            ErrorCopyFile     = "Copying File"
            ErrorDelFile      = "Deleting File"
            ErrorDelExtraFile = "Deleting Extra File"
			
			#Parsing Summary
            DirsSummary  = "Dirs :"
            FilesSummary = "Files :"
            Bytes        = "Bytes :"
            Times        = "Times :"
            Ended        = "Ended :"

            #Warning Script
            WarningDateTime                = "Timestamp could not be converted to DateTime."
            WarningNewFileExist            = "New File           : This entry already exist and will not be added."
            WarningModifiedFileExist       = "Modified File      : This entry already exist and will not be added."
            WarningNewerFileExist          = "Newer File         : This entry already exist and will not be added."
            WarningOlderFileExist          = "Older File         : This entry already exist and will not be added."
            WarningExtraFileExist          = "Extra File         : This entry already exist and will not be added."
            WarningTweakedFileExist        = "Tweaked File (Attr): This entry already exist and will not be added."
            WarningFailedFileExist         = "Failed File        : This entry already exist and will not be added."
            WarningFailedTimeFromInnerLog  = "Unable to calculate TotalTimeFromInnerLog due to incorrect date format in Robocopy log"
            WarningFailedTimeFromMetadata  = "Unable to calculate TotalTimeFromFile due to an error with the file metadata."
        }

        "fr-FR" = @{
            # Added non-breaking space (Unicode \u00A0)
            # Added é accent  (Unicode \u00E9)
            #RobocopParsing
            RobocopParsingStart    = "D$([char]0x00E9)but du parsing..."
            RobocopParsingFinalize = "Fin du parsing..."

            #Parsing header
            Start        = "D$([char]0x00E9)marrage$([char]0x00A0):"
            Source       = "Source :"
            Destination  = "Dest :"
            FilesSection = "Fichiers :"
            Options      = "Options :"
			
			#Parsing Files
            NewFile      = "Nouveau fichier"
            NewerFile    = "Plus r$([char]0x00E9)cent"
            OlderFile    = "Plus ancien"
            SameFile     = "identique"
			ExtraFile    = "Fichier SUPPL."
            ModifiedFile = "Modifi$([char]0x00E9)"
            LonelyFile   = "solitaire"
            TweakedFile  = "<TWEAKED F>"
            	
			#Parsing Directories
            NewDir       = "Nouveau r$([char]0x00E9)p."
            ExtraDir     = "R$([char]0x00E9)p. SUPPL."
            LonelyDir    = "solitaire"

            #Error
            Error             = "ERREUR"
            ErrorCopyFile     = "Copying File"
            ErrorDelFile      = "Deleting File"
            ErrorDelExtraFile = "Deleting Extra File"
			
			#Parsing Summary
            DirsSummary  = "R$([char]0x00E9)p$([char]0x00A0):"  
            FilesSummary = "Fichiers$([char]0x00A0):"
            Bytes        = "Octets$([char]0x00A0):"
            Times        = "Heures:"
            Ended        = "Fin :"

            #Warning Scripts
            WarningDateTime                = "L'horodatage n'a pas pu être converti en DateTime."
            WarningNewFileExist            = "Nouveau Fichier       : Cette entrée existe déjà et ne sera pas ajoutée."
            WarningModifiedFileExist       = "Fichier Modifi$([char]0x00E9)       : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)jà et ne sera pas ajout$([char]0x00E9)e."
            WarningNewerFileExist          = "Fichier R$([char]0x00E9)cent        : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)jà et ne sera pas ajout$([char]0x00E9)e."
            WarningOlderFileExist          = "Fichier Ancien        : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)jà et ne sera pas ajout$([char]0x00E9)e."
            WarningExtraFileExist          = "Fichier Suppl.        : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)jà et ne sera pas ajout$([char]0x00E9)e."
            WarningTweakedFileExist        = "Fichier Modifi$([char]0x00E9) (Attr): Cette entr$([char]0x00E9)e existe d$([char]0x00E9)jà et ne sera pas ajout$([char]0x00E9)e."
            WarningFailedFileExist         = "Fichier Echec         : Cette entr$([char]0x00E9)e existe d$([char]0x00E9)jà et ne sera pas ajout$([char]0x00E9)e."
            WarningFailedTimeFromInnerLog  = "Impossible de calculer TotalTimeFromInnerLog en raison d'un format de date incorrect dans le journal Robocopy"
            WarningFailedTimeFromMetadata  = "Impossible de calculer TotalTimeFromFile en raison d'une erreur avec les m$([char]0x00E9)tadonn$([char]0x00E9)es du fichier."
        }
    }

    $Culture = $CultureMap[$LogLanguage]

    # Initializing the output object
    $Log = [pscustomobject]@{
        HeaderInfo = [pscustomobject]@{
            Start        = $null
        }
        Files = [pscustomobject]@{
            Failed       = @()
        }
        SummaryInfo = [pscustomobject]@{
            Dirs  = [pscustomobject]@{
                Total    = $null
                Copied   = $null
                Skipped  = $null
                Mismatch = $null
                Failed   = $null
                Extras   = $null
            }
            Files = [pscustomobject]@{
                Total    = $null
                Copied   = $null
                Skipped  = $null
                Mismatch = $null
                Failed   = $null
                Extras   = $null
            }
            Ended                 = $null
            TotalTimeFromInnerLog = $null
            TotalTimeStampFromInnerLog = $null
            TotalTimeFromFile     = $null
            TotalTimeStampFromFile = $null
        }
    }

    Write-host "$(get-date -Format "[yyyy-dd-MM HH:mm:ss]") $($Culture.RobocopParsingStart)"

    $FullLogContent = Get-Content -Path $RoboLog -ReadCount 0
    $HeaderLines = $FullLogContent | Select-Object -first 30
    $SummaryLines = $FullLogContent | Select-Object -Last 30

    #region Parsing Header
        # Filtrer les lignes dans $HeaderLines qui correspondent à la regex
        $MatchedStartLine = $HeaderLines | Where-Object { $_ -match "^\s*$($Culture.Start)\s*(.+)$" }

        # Vérifier si une ligne correspondante a été trouvée
        if ($MatchedStartLine) {
            # Capturer l'information correspondante au premier groupe capturé
            $Log.HeaderInfo.Start = $Matches[1].Trim()
        }
    #endregion END Parsing Header

    #region Parsing FailedFiles
    switch ($FailedList) {
        "Raw" {  
            $Log.files.Failed = @($FullLogContent | Where-Object { $_ -match "\s*($($Culture.Error)\s+\d+)\s+\((0x[0-9A-F]+)\)\s+($($Culture.ErrorCopyFile)|$($Culture.ErrorDelFile)|$($Culture.ErrorDelExtraFile))\s+(.+)$"})
        }
        "Parsed" {
            # Parsing détaillé des erreurs capturées
            $Failed = @($FullLogContent | Where-Object { $_ -match "\s*($($Culture.Error)\s+\d+)\s+\((0x[0-9A-F]+)\)\s+($($Culture.ErrorCopyFile)|$($Culture.ErrorDelFile)|$($Culture.ErrorDelExtraFile))\s+(.+)$" })

            foreach ($line in $Failed) {
                <# 
                   Matches est réinitialisé à chaque nouveau -match. Même si Where-Object filtre les lignes correspondantes,
                   il faut réexécuter -match dans la boucle pour chaque ligne et capturer les correspondances dans des variables locales
                   immédiatement, afin de ne pas perdre les données lors des itérations suivantes.
                #>
                if ($line -match "\s*($($Culture.Error)\s+\d+)\s+\((0x[0-9A-F]+)\)\s+($($Culture.ErrorCopyFile)|$($Culture.ErrorDelFile)|$($Culture.ErrorDelExtraFile))\s+(.+)$") {
                    
                    # Capturer les correspondances avant de passer à la ligne suivante
                    $filePath = $Matches[4].Trim()       # Chemin du fichier complet (local ou UNC)
                    $errorInfo = "$($Matches[1]) $($Matches[2])"  # Code d'erreur complet
                    $errorAction = $Matches[3].Trim()    # Action (Copying File, Deleting File, etc.)
    
                    # Vérification si l'erreur est déjà capturée dans la liste des fichiers échoués
                    $FailedFileExists = $Log.Files.Failed | Where-Object {
                        $_.FilePath -eq $filePath -and
                        $_.ErrorInfo -eq $errorInfo -and
                        $_.ErrorAction -eq $errorAction
                    }
    
                    # Ajouter à la liste si l'erreur n'a pas encore été capturée
                    if (-not $FailedFileExists) {
                        $Log.Files.Failed += [pscustomobject]@{
                            FilePath    = $filePath    
                            ErrorInfo   = $errorInfo   
                            ErrorAction = $errorAction 
                        }
                    } else {
                        Write-Warning "$($Culture.WarningFailedFileExist) : $($FailedFileExists.FilePath)"
                    }
                }
            }
        }
        Default {
            $Log.files.Failed = $null
        }
    }
    #region END Parsing FailedFiles

    #region Parsing Summary
        # Filtrer et parser les informations des répertoires dans le Summary
        $dirSummaryLine = $SummaryLines | Where-Object { $_ -match "^\s*$($Culture.DirsSummary)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)$" }

        if ($dirSummaryLine) {
            $Log.SummaryInfo.Dirs.Total    = [int]$Matches[1]
            $Log.SummaryInfo.Dirs.Copied   = [int]$Matches[2]
            $Log.SummaryInfo.Dirs.Skipped  = [int]$Matches[3]
            $Log.SummaryInfo.Dirs.Mismatch = [int]$Matches[4]
            $Log.SummaryInfo.Dirs.Failed   = [int]$Matches[5]
            $Log.SummaryInfo.Dirs.Extras   = [int]$Matches[6]
        }

        # Filtrer et parser les informations des fichiers dans le Summary
        $fileSummaryLine = $SummaryLines | Where-Object { $_ -match "^\s*$($Culture.FilesSummary)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)$" }

        if ($fileSummaryLine) {
            $Log.SummaryInfo.Files.Total    = [int]$Matches[1]
            $Log.SummaryInfo.Files.Copied   = [int]$Matches[2]
            $Log.SummaryInfo.Files.Skipped  = [int]$Matches[3]
            $Log.SummaryInfo.Files.Mismatch = [int]$Matches[4]
            $Log.SummaryInfo.Files.Failed   = [int]$Matches[5]
            $Log.SummaryInfo.Files.Extras   = [int]$Matches[6]
        }

        # Filtrer et parser l'heure de fin dans le Summary
        $endedSummaryLine = $SummaryLines | Where-Object { $_ -match "^\s*$($Culture.Ended)\s*(.+)$" }

        if ($endedSummaryLine) {
            $Log.SummaryInfo.Ended = $Matches[1].Trim()
        }

    #endregion END Parsing Summary
    
    #region Calculation Extra data
        # Calculate total time based on HeaderInfo.Start and SummaryInfo.Ended if exists
        if ($Log.HeaderInfo.Start -and $Log.SummaryInfo.Ended) {
            try {
                # Use Get-Date to convert dates
                $startTime = Get-Date -Date $Log.HeaderInfo.Start
                $endTime = Get-Date -Date $Log.SummaryInfo.Ended

                # Calculation of duration
                $duration = $endTime - $startTime

                # Calculation of duration in seconds
                $Log.SummaryInfo.TotalTimeStampFromInnerLog = [math]::Round($duration.TotalSeconds)

                # Formatting the result in Days:Hours:Minutes:Seconds
                $Log.SummaryInfo.TotalTimeFromInnerLog = "{0:D2}d:{1:D2}h:{2:D2}m:{3:D2}s" -f $duration.Days, $duration.Hours, $duration.Minutes, $duration.Seconds
            }
            catch {
                Write-Warning "$($Culture.WarningFailedTimeFromInnerLog)"
            }
        }

        # Calculation of total time based on file metadata (creation and modification)
        try {
            $fileInfo = Get-Item $RoboLog
            $creationTime = $fileInfo.CreationTime
            $lastWriteTime = $fileInfo.LastWriteTime

            # If the creation date is greater than the modification date, the dates are reversed
			# I had this case when creating a file on a server with time out of sync and file re-modified on another machine with another timeset
            if ($creationTime -gt $lastWriteTime) {
                $fileDuration = $creationTime - $lastWriteTime
            } else {
                $fileDuration = $lastWriteTime - $creationTime
            }

            # Calculation of duration in seconds
            $Log.SummaryInfo.TotalTimeStampFromFile = [math]::Round($fileDuration.TotalSeconds)

            # Formatting the result in Days:Hours:Minutes:Seconds
            $Log.SummaryInfo.TotalTimeFromFile = "{0:D2}d:{1:D2}h:{2:D2}m:{3:D2}s" -f $fileDuration.Days, $fileDuration.Hours, $fileDuration.Minutes, $fileDuration.Seconds
        }
        catch {
            Write-Warning "$($Culture.WarningFailedTimeFromMetadata)"
        }
    #endregion END Calculation Extra data

    Write-Host "$(get-date -Format "[yyyy-dd-MM HH:mm:ss]") $($Culture.RobocopParsingFinalize)"

	#return Object
    return $Log
}

try{
    $ReturnLog = (ConvertFrom-RobocopLogLite -RoboLog $RoboLog -LogLanguage $LogLanguage -FailedList $FailedList)
	return $ReturnLog
}catch{
    Write-Error $_
}
